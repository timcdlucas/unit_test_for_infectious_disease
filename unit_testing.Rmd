---
output:
  bookdown::pdf_document2:
    number_sections: true
    toc: false
    keep_tex: true
title: "Test, test me do: unit testing for infectious disease modelling"
author: Tim CD Lucas, Tim Pollington, Deirdre Hollingsworth, et al.
geometry: margin=1in
bibliography: unit_testing.bib
---


<!--
To build run
rmarkdown::render('unit_testing.Rmd')
-->



<!--
Title: A beginners guide to unit testing for infectious disease epidemiologists
Title: A guide for effective unit testing for robust, infectious disease code.
-->


<!--
# use covid Ferguson as motivating example.
# https://twitter.com/neil_ferguson/status/1241835454707699713?s=19


# good practice
#.   small functions

# what to test
#.  edge cases. 0, others?
  #.  types
#.  dims
#.  bounds


# how to test random
#.   non random pars. p= 0
#.   separate the random bit
#.   large numbers and bounds
#.   Test for rare events again with large number


# frameworks
#.  testthat and packages
#.  test in Julia
#.  add python

# continuous integration
-->


```{r, setup, echo = FALSE}
library(ggplot2)
library(testthat)
knitr::opts_chunk$set(cache = FALSE, fig.width = 7, fig.height = 4, 
                      out.extra = '', out.width = "0.6\\textwidth",
                      fig.align='center')
```

# Abstract

We use code.

Noone is bug free.

it is important that out code is correct because people live or die

buggy code is biased code

people currently use as hoc testing.

We did a review and few people were writing tests.

really we should be doing unit testing

unit testing is formally defined tests in a framework that encourages them to be regularly run.

# Introduction

Infectious disease modellers write lots of code.
Code is getting more complex as IBMs become more popular [@willem2017lessons; @ferguson2006strategies].
That code is important because it directs policy.
examples include covid and another example where models have directly influenced policy.

Given that modelling is important, it is important for the code to be correct.
Neil Ferguson got flack for code that wasn't written with software best practices.
Furthermore, buggy code is biased code, with an example.
However, most researchers currently do tests as hoc and only once.

unit testing is a framework for doing this properly (@wickham2015r Chapter 7, @osborne2014ten, @wilson2014best).
useful frameworks are readily available in R and Julia and python.
infectious disease modelling presents some specific challenges such as stochastic code.
in this primer we introduce unit testing and demonstrate its use on an example infectious disease model.
we give specific recommendations for the problems specific to infectious disease modelling.
we also give an overview of the testing frameworks and continuous integration options available.


# Unit testing basics


Unit testing consists of pairs of function calls and known/expected outputs.
So far a function that computes the square root of a number, we would write a test that runs our function on the number 4 and compares it to the known, correct answer (2).
We would write tests that cover various possible inputs: what do we want our function to do if it is given a negative number, or a string instead of a numeric object?

In R [@R], the testthat package [@testthat], provides a simple interface for testing.
While there are a number of test functions, the two main functions is `expect_true` and `expect_equal`. 
`expect_true` takes one argument, an expression that should evaluate to true.
So for our square root example above we would write `expect_true(sqrt(4) == 2)`.
`expect_equal` takes two arguments, an expression and the expected output.
For the square root example we would write `expect_equal(sqrt(4), 2)`.

There are a number of ways that unit testing can be incorporated into programming workflow.
The first and clearest is that as you write code, you should write tests that test the code does what you think it does.
The second, is that these same tests should then be regularly run as you continue to develop code.
If a change elsewhere in the code causes the older tests to break, something has gone wrong and needs to be fixed.
Finally, you can write tests before you write code.
This can be a helpful way to force yourself to plan what some new code or functionality is expected to do.
Write tests that define the wanted functionality, and keep on programming until all the tests pass.
This is known as test-driven development.
Frameworks for formalising these frameworks are discussed in Sections [6](frameworks) and [7](ci).



# Example

<!--
# this example should
#  demonstrate that bugs can be subtle
#  Have elements that are fixable by all the ideas later
-->

Here we define a simple epidemiological model and then present R code for it.
We will then use this as a working example to demonstrate how to effectively write unit tests for infectious disease modelling code.

Consider a multistrain system, where a population of $N$ individuals who get reinfected once per time step.
Each individual is defined by the strain they are currently infected with $I_{it} \in \{a, b, c\}$ and so the the population is defined by the length $N$ vector of states $\mathbf{I}_t$.
Then each time step, the infection status of each individual is updated
$$I_{it} = \text{Unif}(\mathbf{I}_{t-1}).$$

Here then is our first attempt at implementing this model.

```{r, simsetup, results = 'hide', echa = FALSE}
set.seed(3132)
```


```{r, first_code, results = 'hide'}
N <- 12
t <- 20
# create the matrix to store the simulation data
I <- matrix(NA, ncol = N, nrow = t)

# Initialise the population
I[1, ] <- rep(c("a", "b", "c"), N / 3)

# For each time step, each person is reinfected
#   by someone randomly sampled from the population.
for(t in seq(2, t)){
  I[t, ] <- sample(I[t - 1, ], N)
}
```

We might then make some plots to explore whether our code is doing something sensible.
For example we might plot the time course of one or more individuals and see that they are being repeatedly infected with different strains as expected (Figure \@ref(fig:firstplots)).
However, if we look at the proportion of each strain through time (not plotted) we will quickly see that the proportions do not change.
Therefore there must be a bug in our code.

This simple example demonstrates a number of points.
Firstly, something that everyone who has ever written code knows, bugs can be subtle.
Even though the code above is only a few lines, it is not easy to notice that it is wrong.
Secondly, it is much easier to debug code, once you know there is a bug.
Once you know there is a bug in the above code, some proportion of readers might be able to identify the bug.
Thirdly, this example is not far from the testing that many scientists do; write the code, plot some outputs and see if they make sense.
However, approaching this in an ad hoc way makes it less likely that we will catch bugs.
In this example, we used the wrong plot to diagnose whether our code was correct and therefore missed the bug.
Finally, while plots are an excellent way to check the behaviour of code, and plotting simulation runs is a vital step in code checking, it is not the easiest method for automatically checking code because a human has to scan each plot each time the tests are run.



```{r, firstplots, echo = FALSE, fig.cap = 'The infection status of one individual though time.'}
d1 <- data.frame(time = seq(t), strain = I[, 1])
d1$strain_num <- as.numeric(factor(d1$strain))
ggplot(d1, aes(time, strain_num)) + 
  geom_path() +
  geom_point() +
  scale_y_continuous(breaks = seq(3), labels = c('a', 'b', 'c')) +
  labs(y = 'Strain', x = 'Time')
```


```{r, firstplots2, echo = FALSE, result = 'hide', include = FALSE}
d1 <- data.frame(time = rep(seq(t), 3), 
                 strain = as.vector(I[, 1:3]),
                 individual = factor(rep(1:3, each = t)))
d1$strain_num <- as.numeric(factor(d1$strain))
ggplot(d1, aes(time, strain_num, colour = individual, group = individual)) + 
  geom_path() +
  scale_y_continuous(breaks = seq(3), labels = c('a', 'b', 'c')) +
  labs(y = 'Strain', x = 'Time', colour = 'Indiv.')
```


```{r, bug_show_plot, include = FALSE}
apply(I, 1, function(x) table(factor(x, levels = c("a", "b", "c")))) %>% t %>% matplot(type = 'l')
```

The fix for this particular bug is that the `sample` function defaults to sampling without replacement.
Setting `replace = TRUE` fixes the code and when we plot the proportion of each strain (Figure \@ref{fig:correctplots}) we now see the correct behaviour.
Given this example, we will now work through specific advice for unit testing for infectious disease models.
We will write tests and rewrite the code as we go until we have a well tested, more reliabley implemented model at the end.

```{r, correct_code, results = 'hide', echo = FALSE}
N <- 12
t <- 20
I <- matrix(NA, ncol = N, nrow = t)
I[1, ] <- rep(c("a", "b", "c"), N / 3)

for(i in seq(2, t)){
  I[i, ] <- sample(I[i - 1, ], N, replace = TRUE)
}
```



```{r, correctplots, echo = FALSE, fig.cap = 'The correct behaviour with the proportion of each strain drifting. Each strain is a different line.'}
(apply(I, 1, function(x) table(factor(x, levels = c("a", "b", "c")))) / N) %>% 
  t %>% 
  matplot(type = 'l', xlab = 'Time', ylab = 'Proportion', lwd = 2)
```


# Tips and best practice

## Basic testing
### Write small functions {-#smallfuns}

In order to guarantee that a unit test is checking the same code as used for actual analysis, the code needs to be defined once, in a function.
This same function is then used in the larger model code and used by the unit test itself.
It helps to make your functions small, such that they do one, clearly defined operation.
This makes it easier to reason through a few examples to be confident you know exactly what the output should be.
In our example we could define one function to initialise the population and another to run the simulation.
In doing so we can more carefully consider the structure of our code more generally.
Here we have modified the code that initialises the population so that we can vary the number of strains and so that the number of individuals does not have to be a multiple of the number of strains.

```{r, refactor, result = 'hide'}
initialise_pop <- function(N, t, strains = 3){
  I <- matrix(NA, ncol = N, nrow = t)
  I[1, ] <- rep(letters[1:strains], ceiling(N / strains))[1:N]
  return(I)
}

update_pop <- function(x, N, i){
  x[i, ] <- sample(x[i - 1, ], N, replace = TRUE)
  return(x)
}
```



### Test easy to understand parameters {-#easyparams}

In order to carefully work out exactly what we expect each function to do, it is useful to use easy to understand parameters.
For example, if we set up a very small populations with only a few strains we can easily work out exactly what we expect the initialised population to look like.


```{r, test_easy, results = 'hide'}
pop1 <- initialise_pop(3, 2, strain = 2) 
expect_equal(pop1[1, ], c('a', 'b', 'a'))

pop2 <- initialise_pop(3, 2, strain = 3) 
expect_equal(pop2[1, ], c('a', 'b', 'c'))

pop3 <- initialise_pop(4, 2, strain = 2) 
expect_equal(pop3[1, ], c('a', 'b', 'a', 'b'))
```

### Test all arguments {-#testargs}

Our function `initialise_pop` has three arguments so we should test that each of these does what we expect.
To do this we will initialise one population, and then alter each argument in turn.
The first two arguments directly change the expected dimension of the output matrix, so we test that.
For the last argument we have tested that the number of strains is equal to the number of strains requested.

```{r, test_all_args, results = 'hide'}
pop <- initialise_pop(3, 2, strain = 3) 
expect_equal(dim(pop), c(2, 3))

pop2 <- initialise_pop(3, 6, strain = 3) 
expect_equal(dim(pop2), c(6, 3))

pop3 <- initialise_pop(20, 2, strain = 3) 
expect_equal(dim(pop3), c(2, 20))

pop4 <- initialise_pop(10, 2, strain = 5) 
expect_equal(length(unique(pop4[1, ])), 5)

```



### Carefully work through more complex parameters {-#complexparams}

We can also write tests for each function with less simple parameter values.
After initialising our population, we expect all the rows other than the first to contain NAs.
We also expect each of the strains a, b and c to occur in the first row.
Our function update performs one time step of the simulation, so we expect one additional row to be populated.
Instead of testing the exact values of the results here, we are testing that they make sense with our more macro understanding of the model system.

```{r, test_complex, results = 'hide'}
pop <- initialise_pop(12, 20) 
expect_true(all(is.na(pop[-1, ])))
expect_true(all(c('a', 'b', 'c') %in% pop[1, ]))

pop2 <- update_pop(pop, 12, 2)
expect_true(all(!is.na(pop2[1:2, ])))
```


### Combine smaller functions and test the upper-level functions {-#combine}

There are many aspects of code that are best tested using small, specific functions.
However, we also need to test that we are tying these functions together properly.
Therefore, we should write larger functions that can also be tested.

```{r, refactor2, result = 'hide'}

full_sim <- function(N, t){
  pop <- initialise_pop(N, t) 
  for(i in seq(2, t)){
    pop <- update_pop(pop, N, i)
  }
  return(pop)
}

```

Where possible we should test larger, more macro aspects of the model here.
We now expect there to be no NAs left in our matrix.
We also now expect every element in our matrix to be one of the three strain strings.

```{r, testnn, results = 'hide'}
pop <- full_sim(12, 20)
expect_true(!any(is.na(pop)))
expect_true(all(pop %in% c('a', 'b', 'c')))
```



## Testing stochastic code

One of the most particular challenges for testing code for infectious disease modelling is the large amount of stochastic events.
Stochastic events are difficult to test effectively because, by definition, we do not know exactly what the result will be.
There are however a number of approaches that can help.

### Split stochastic and deterministic parts {-#splitstochastic}

The first thing to aim for is to isolate the stochastic parts of the code.
For example, the function `update_pop` above does a number of things, some of which are stochastic and some of which are deterministi.
Firslty, the function stochastically samples who gets infected by whom.
Then it takes those infection events and finds the new infectious status for each individual.
Finally, it adds the new infectious statuses to the full population matrix. 
So we could split these tasks up as follows.

```{r, refactorstoch}

sample_events <- function(N){
  sample(N, N, replace = TRUE)
}

new_infection_status <- funtion(old_i, events){
  old_i[sample_events]
}

add_infectious_status <- funtion(x, new_i, i){
  x[i, ] <- new_i
}

update_pop <- function(x, N, i){
  events <- sample_events(N)
  new_i <- new_infectious_status(x[i - 1, ])
  x <- add_infectious_status(x, new_i, i)
  return(x)
}

```

Now two thirds of the code is deterministic and can be tested using the ideas discussed previously.
Similarly, the function `update_pop` that combines these functions can be tested at a more macro level, confident that two thirds of the code inside it is already tested very carefully.
However, we still have one function, `sample_events`, that is irreducably stochastic.


### Test deterministic parameters for stochastic code {-#deterministicparams}

Similarly to finding parameters that are simple to test for other functions, we can often find parameter values for which our stochastic functions are not longer stochastic.
For example, a bernoulli sample with probability 0 always gives a 0 and with a probability of 1 always gives a 1.
In the example here, in the case where we only have one strain, the model is no longer stochastic.

### Test all possible answers {-#allpossible}

### Use very large samples for stochastic part {-#largesmaples}

This includes testing large numbers so that you can get a very likely range.
But also includes testing many runs to check for rare events.
Remember to set the seed.



## Further testing
### Test corner cases {-#corners}





### Test incorrect inputs {-#testincorrect}

This is especially important for user facing functions.
The author of the code is also a user!
If a function will be used for new datasets, test that is handles NAs, NaNs, etc.
Consider defensive programming.

# Unit testing frameworks {#frameworks}

Does this need to go at the beginning as we are already introducing testthat? I would rather not put it at the beginning...

testthat we already introduced

Test in Julia

If we build our code as packages this is set up as well

testthat in an r package
devtools::check runs checks that the r package is built correctly and runs unit tests.

Test in a Julia package


# Continuous integration {#ci}

If the code is hosted as a remote repo, we can deploy continuous integration so that tests are run every time we push changes.

For open source packages, services like Travis ci are free.
simply add a traits yml file, sign up, point travis to your repo.
Similarly, services like codecov measure how much of your code is tested.




# Conclusions


# References
