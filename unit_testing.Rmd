---
output:
  pdf_document:
    number_sections: true
    keep_tex: true
title: "Test, test me do: unit testing for infectious disease modelling"
author: Tim CD Lucas, Tim Pollington, Deirdre Hollingsworth, et al.
geometry: margin=1in
bibliography: unit_testing.bib
---


<!--
To build run
rmarkdown::render('unit_testing.Rmd')
-->



<!--
Title: A beginners guide to unit testing for infectious disease epidemiologists
Title: A guide for effective unit testing for robust, infectious disease code.
-->


<!--
# use covid Ferguson as motivating example.
# https://twitter.com/neil_ferguson/status/1241835454707699713?s=19


# good practice
#.   small functions

# what to test
#.  edge cases. 0, others?
  #.  types
#.  dims
#.  bounds


# how to test random
#.   non random pars. p= 0
#.   separate the random bit
#.   large numbers and bounds
#.   Test for rare events again with large number


# frameworks
#.  testthat and packages
#.  test in Julia
#.  add python

# continuous integration
-->


# Abstract

We use code.

Noone is bug free.

it is important that out code is correct because people live or die

buggy code is biased code

people currently use as hoc testing.

We did a review and few people were writing tests.

really we should be doing unit testing

unit testing is formally defined tests in a framework that encourages them to be regularly run.

# Introduction

Infectious disease modellers write lots of code.
That code is important because it directs policy.
examples include covid and another example where models have directly influenced policy.

Given that modelling is important, it is important for the code to be correct.
Neil Ferguson got flack for code that wasn't written with software best practices.
Furthermore, buggy code is biased code, with an example.
However, most researchers currently do tests as hoc and only once.

unit testing is a framework for doing this properly (@wickham2015r Chapter 7, @osborne2014ten).
useful frameworks are readily available in R and Julia and python.
infectious disease modelling presents some specific challenges such as stochastic code.
in this primer we introduce unit testing and demonstrate its use on an example infectious disease model.
we give specific recommendations for the problems specific to infectious disease modelling.
we also give an overview of the testing frameworks and continuous integration options available.


# Unit testing basics


Unit testing consists of pairs of function calls and known/expected outputs.
So far a function that computes the square root of a number, we would write a test that runs our function on the number 4 and compares it to the known, correct answer (2).
We would write tests that cover various possible inputs: what do we want our function to do if it is given a negative number, or a string instead of a numeric object?

In R [@R], the testthat package [@testthat], provides a simple interface for testing.
While there are a number of test functions, the main function is expect_true and takes one argument, an expression that should evaluate to true.
So for our square root example above we would write expect_true(sqrt(4) == 2).

There are a number of ways that unit testing can be incorporated into programming workflow.
The first and clearest is that as you write code, you should write tests that test the code does what you think it does.
The second, is that these same tests should then be regularly run as you continue to develop code.
If a change elsewhere in the code causes the older tests to break, something has gone wrong and needs to be fixed.
Finally, you can write tests before you write code.
This can be a helpful way to force yourself to plan what some new code or functionality is expected to do.
Write tests that define the wanted functionality, and keep on programming until all the tests pass.
This is known as test-driven development.
Frameworks for formalising these frameworks are discussed in Sections [6](frameworks) and [7](ci).



# Example

<!--
# this example should
#  demonstrate that bugs can be subtle
#  Have elements that are fixable by all the ideas later
-->

Here we define a simple epidemiological model and then present R code for it.
We will then use this as a working example to demonstrate how to effectively write unit tests for infectious disease modelling code.

Consider a multistrain system, where a population of $N$ individuals who get reinfected once per time step.
Each individual is defined by the strain they are currently infected with $I_{it} \in \{'a', 'b', 'c'\}$ and so the the population is defined by the length $N$ vector of states $\mathbf{I}_t$.
Then each time step, the infection status of each individual is updated
$$I_{it} = \text{Unif}(\mathbf{I}_{t-1}).$$

Here then is our first attempt at implementing this model.

```{r, setup, results = 'hide', echa = FALSE}
set.seed(3132)
```


```{r, first_code, results = 'hide'}
N <- 12
t <- 20
I <- matrix(NA, ncol = N, nrow = t)
I[1, ] <- rep(c("a", "b", "c"), N / 3)

for(t in seq(2, t)){
  I[t, ] <- sample(I[t - 1, ], N)
}
```



```{r, firstplots}
I[, 1] %>% factor %>% as.numeric() %>% plot(type = 'l')
apply(I, 1, function(x) table(factor(x, levels = c("a", "b", "c")))) %>% t %>% matplot(type = 'l')

```



```{r, correct_code, results = 'hide'}
N <- 12
t <- 20
I <- matrix(NA, ncol = N, nrow = t)
I[1, ] <- rep(c("a", "b", "c"), N / 3)

for(t in seq(2, t)){
  I[t, ] <- sample(I[t - 1, ], N, replace = TRUE)
}
```


```{r, correct_plots}
apply(I, 1, function(x) table(factor(x, levels = c("a", "b", "c")))) %>% t %>% matplot(type = 'l')
```

# Tips and best practice

## Write functions

In order to guarantee that a unit test is checking the same code as used in the model, the code needs to be defined once, in a function.
This same function is then used in the larger model code and used by the unit test itself.

## Write small functions

In order to effectively write unit tests it helps to make your functions small, such that they do one, clearly defined operation.
This makes it easier to reason through a few examples to be confident you know exactly what the output should be.

## Combine smaller functions and test the upper-level functions



## Test easy to understand parameters



## Carefully work through more complex parameters

## Test corner cases

## Test structure as well as values


## Test incorrect inputs

This is especially important for user facing functions.
The author of the code is also a user!
If a function will be used for new datasets, test that is handles NAs, NaNs, etc.
Consider defensive programming.

## Split stochastic and deterministic parts

## Test deterministic parameters for stochastic code

## Use very large samples for stochastic part

This includes testing large numbers so that you can get a very likely range.
But also includes testing many runs to check for rare events.
Remember to set the seed.





# Unit testing frameworks {#frameworks}

Does this need to go at the beginning as we are already introducing testthat? I would rather not put it at the beginning...

testthat we already introduced

Test in Julia

If we build our code as packages this is set up as well

testthat in an r package
devtools::check runs checks that the r package is built correctly and runs unit tests.

Test in a Julia package


# Continuous integration {#ci}

If the code is hosted as a remote repo, we can deploy continuous integration so that tests are run every time we push changes.

For open source packages, services like Travis ci are free.
simply add a traits yml file, sign up, point travis to your repo.
Similarly, services like codecov measure how much of your code is tested.




# Conclusions


# References
