% Template for PLoS
% Version 3.5 March 2018
%
% % % % % % % % % % % % % % % % % % % % % %
%
% -- IMPORTANT NOTE
%
% This template contains comments intended
% to minimize problems and delays during our production
% process. Please follow the template instructions
% whenever possible.
%
% % % % % % % % % % % % % % % % % % % % % % %
%
% Once your paper is accepted for publication,
% PLEASE REMOVE ALL TRACKED CHANGES in this file
% and leave only the final text of your manuscript.
% PLOS recommends the use of latexdiff to track changes during review, as this will help to maintain a clean tex file.
% Visit https://www.ctan.org/pkg/latexdiff?lang=en for info or contact us at latex@plos.org.
%
%
% There are no restrictions on package use within the LaTeX files except that
% no packages listed in the template may be deleted.
%
% Please do not include colors or graphics in the text.
%
% The manuscript LaTeX source should be contained within a single file (do not use \input, \externaldocument, or similar commands).
%
% % % % % % % % % % % % % % % % % % % % % % %
%
% -- FIGURES AND TABLES
%
% Please include tables/figure captions directly after the paragraph where they are first cited in the text.
%
% DO NOT INCLUDE GRAPHICS IN YOUR MANUSCRIPT
% - Figures should be uploaded separately from your manuscript file.
% - Figures generated using LaTeX should be extracted and removed from the PDF before submission.
% - Figures containing multiple panels/subfigures must be combined into one image file before submission.
% For figure citations, please use "Fig" instead of "Figure".
% See http://journals.plos.org/plosone/s/figures for PLOS figure guidelines.
%
% Tables should be cell-based and may not contain:
% - spacing/line breaks within cells to alter layout or alignment
% - do not nest tabular environments (no tabular environments within tabular environments)
% - no graphics or colored text (cell background color/shading OK)
% See http://journals.plos.org/plosone/s/tables for table guidelines.
%
% For tables that exceed the width of the text column, use the adjustwidth environment as illustrated in the example table in text below.
%
% % % % % % % % % % % % % % % % % % % % % % % %
%
% -- EQUATIONS, MATH SYMBOLS, SUBSCRIPTS, AND SUPERSCRIPTS
%
% IMPORTANT
% Below are a few tips to help format your equations and other special characters according to our specifications. For more tips to help reduce the possibility of formatting errors during conversion, please see our LaTeX guidelines at http://journals.plos.org/plosone/s/latex
%
% For inline equations, please be sure to include all portions of an equation in the math environment.
%
% Do not include text that is not math in the math environment.
%
% Please add line breaks to long display equations when possible in order to fit size of the column.
%
% For inline equations, please do not include punctuation (commas, etc) within the math environment unless this is part of the equation.
%
% When adding superscript or subscripts outside of brackets/braces, please group using {}.
%
% Do not use \cal for caligraphic font.  Instead, use \mathcal{}
%
% % % % % % % % % % % % % % % % % % % % % % % %
%
% Please contact latex@plos.org with any questions.
%
% % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[10pt,letterpaper]{article}
\usepackage[top=0.85in,left=2.75in,footskip=0.75in]{geometry}

% amsmath and amssymb packages, useful for mathematical formulas and symbols
\usepackage{amsmath,amssymb}

% Use adjustwidth environment to exceed column width (see example table in text)
\usepackage{changepage}

% Use Unicode characters when possible
\usepackage[utf8x]{inputenc}

% textcomp package and marvosym package for additional characters
\usepackage{textcomp,marvosym}

% cite package, to clean up citations in the main text. Do not remove.
% \usepackage{cite}

% Use nameref to cite supporting information files (see Supporting Information section for more info)
\usepackage{nameref,hyperref}

% line numbers
\usepackage[right]{lineno}

% ligatures disabled
\usepackage{microtype}
\DisableLigatures[f]{encoding = *, family = * }

% color can be used to apply background shading to table cells only
\usepackage[table]{xcolor}

% array package and thick rules for tables
\usepackage{array}

% create "+" rule type for thick vertical lines
\newcolumntype{+}{!{\vrule width 2pt}}

% create \thickcline for thick horizontal lines of variable length
\newlength\savedwidth
\newcommand\thickcline[1]{%
  \noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
  \cline{#1}%
  \noalign{\vskip\arrayrulewidth}%
  \noalign{\global\arrayrulewidth\savedwidth}%
}

% \thickhline command for thick horizontal lines that span the table
\newcommand\thickhline{\noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
\hline
\noalign{\global\arrayrulewidth\savedwidth}}


% Remove comment for double spacing
%\usepackage{setspace}
%\doublespacing

% Text layout
\raggedright
\setlength{\parindent}{0.5cm}
\textwidth 5.25in
\textheight 8.75in

% Bold the 'Figure #' in the caption and separate it from the title/caption with a period
% Captions will be left justified
\usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
\renewcommand{\figurename}{Fig}

% Use the PLoS provided BiBTeX style
% \bibliographystyle{plos2015}

% Remove brackets from numbering in List of References
\makeatletter
\renewcommand{\@biblabel}[1]{\quad#1.}
\makeatother



% Header and Footer with logo
\usepackage{lastpage,fancyhdr,graphicx}
\usepackage{epstopdf}
%\pagestyle{myheadings}
\pagestyle{fancy}
\fancyhf{}
%\setlength{\headheight}{27.023pt}
%\lhead{\includegraphics[width=2.0in]{PLOS-submission.eps}}
\rfoot{\thepage/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
\fancyheadoffset[L]{2.25in}
\fancyfootoffset[L]{2.25in}
\lfoot{\today}

%% Include all macros below

\newcommand{\lorem}{{\bf LOREM}}
\newcommand{\ipsum}{{\bf IPSUM}}

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}


\usepackage{caption}
\usepackage{floatrow}

\DeclareNewFloatType{chunk}{placement=h, fileext=chk, name=}
\captionsetup{options=chunk}
\renewcommand{\thechunk}{Code~\arabic{chunk}}
\makeatletter
\@addtoreset{chunk}{section}
\makeatother



\usepackage{forarray}
\usepackage{xstring}
\newcommand{\getIndex}[2]{
  \ForEach{,}{\IfEq{#1}{\thislevelitem}{\number\thislevelcount\ExitForEach}{}}{#2}
}

\setcounter{secnumdepth}{0}

\newcommand{\getAff}[1]{
  \getIndex{#1}{Big Data Institute,MathSys CDT}
}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\begin{document}
\vspace*{0.2in}

% Title must be 250 characters or less.
\begin{flushleft}
{\Large
\textbf\newline{Unit testing for infectious disease modelling\\
~\\
A beginner's guide to unit testing for infectious disease epidemiologists\\
~\\
A guide for effective unit testing for robust, infectious disease code\\
~\\
Unit testing for disease modelling\\
~\\
First steps in unit testing for your disease model} % Please use "sentence case" for title and headings (capitalize only the first word in a title (or heading), the first word in a subtitle (or subheading), and any proper nouns).
}
\newline
% Insert author names, affiliations and corresponding author email (do not include titles, positions, or degrees).
\\
Tim CD Lucas\textsuperscript{\getAff{Big Data Institute}}\textsuperscript{*},
Timothy M Pollington\textsuperscript{\getAff{Big Data Institute}, \getAff{MathSys CDT}},
T DÃ©irdre Hollingsworth\textsuperscript{\getAff{Big Data Institute}}\\
\bigskip
\textbf{\getAff{Big Data Institute}}Big Data Institute, Li Ka Shing Centre for Health Information and Discovery, University of Oxford, UK\\
\textbf{\getAff{MathSys CDT}}MathSys CDT, University of Warwick, UK\\
\bigskip
* Corresponding author: timcdlucas@gmail.com\\
\end{flushleft}
% Please keep the abstract below 300 words
\section*{Abstract}
Models are the keystone of infectious disease epidemiology and are increasingly reliant on computers rather than pen-and-paper methods.
Models of infectious disease help guide health policy that can affect millions of people.
Yet a single bug could bias results, leading to incorrect conclusions and wrong actions that could cause avoidable harm.
We are ethically obliged to ensure our code is as free of error as possible.
Software engineering already provides a solution in \emph{unit testing}, a coding method that aims to avoid bugs in code.

We demonstrate through simple examples how unit testing can handle the particular quirks of infectious disease models and encourage modellers to try it out in their next script.

% Please keep the Author Summary between 150 and 200 words
% Use first person. PLOS ONE authors please skip this step.
% Author Summary not valid for PLOS ONE submissions.

\linenumbers

% Use "Eq" instead of "Equation" for equation citations.
\newpage

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Modelling is a hugely important tool in epidemiology as a way to understand fundamental biological processes, test intervention efficacy and forecast disease burden.
For instance models are currently providing advice to governments on their response to the COVID-19 pandemic {[}1--3{]}.
Similarly, policy on endemic infectious diseases is also directed by models TODO {[}an\_ntd\_paper\_that\_definitely\_influenced\_policy{]}.
The decisions based on these models could significantly affect, to different degrees, the health outcomes of millions of people globally.

Given the importance of modelling results, it is vital that they are both correct and trusted.
The issue of trust was highlighted recently when Neil Ferguson, one of the leading modellers informing UK COVID-19 government policy, tweeted:

\begin{quote}
``I'm conscious that lots of people would like to see and run the pandemic simulation code we are using to model control measures against COVID-19. To explain the background - I wrote the code (thousands of lines of undocumented C) 13+ years ago to model flu pandemics\ldots{}'' {[}4{]}.
\end{quote}

The tweet garnered considerable backlash, with observers from the software industry noting that code should be both documented and tested to ensure its correctness.
Until the code is published we cannot comment on how it was tested.
Our aim here is certainly not to single out a single scientist. Indeed testing is scant in epidemiology, especially in fast-moving epidemics TODO{[}substantiate{]}.

Today's models are increasingly moving from mean-field ordinary differential equation approximations to individual-based models with complex, data-driven contact processes {[}5,6{]}.
These increases in model complexity are accompanied with growing codebases.
As the mathematical methods depend on numerical solutions rather than analytical pen-and-paper methods, it soon becomes difficult to tell a bug is present based on model outputs.

The workflow followed by many is to write some code, run the full model and examine plots of the output.
This crude \emph{ad hoc} testing approach can miss many bugs.
Furthermore, this workflow is biased as models that show expected behaviour are assumed bug-free, while models showing unexpected behaviour get more scrutiny.

\emph{Unit testing} is a formally-defined, principled framework that compares numerous output scenarios from code to what the programmer expected to happen ({[}7{]} Chapter 7, {[}8{]}, {[}9{]}).
Ready-to-run frameworks for unit testing are available in \emph{R} {[}10{]}, \emph{Julia} {[}11{]} and \emph{python} {[}12{]} and standard practice in the software industry.
These testing concepts also apply to ecology and other sciences but here we focus on infectious diseases.
Infectious disease modelling presents specific challenges, such as stochastic outputs, which are difficult to test and not covered in general unit testing literature.

In this primer we introduce unit testing and demonstrate its use on an example infectious disease model.
We also give an overview of the available testing frameworks in various languages commonly used by infectious disease modellers.

\hypertarget{unit-testing-foundations}{%
\section{Unit testing foundations}\label{unit-testing-foundations}}

At the heart of every unit test is a function output, its known/expected value and a process to compare the two.
For the square root function \(\sqrt{x}\) (\texttt{sqrt(x)} in \emph{R} {[}10{]}), we would write a test that runs the function call on the number 4 i.e. \texttt{sqrt(x\ =\ 4)} and compares it to the correct answer i.e.~2.
Often our function arguments will cover an infinite range of possibilities and we cannot exhaustively check them all.
Instead we devise tests that cover standard usage as well as \emph{corner case} scenarios: what do we want our function to do if given a negative number e.g. \texttt{sqrt(-1)}, or a vector argument containing strings or missing values e.g. \texttt{sqrt(c(4,"melon",NA))}?

In \emph{R}, the \texttt{testthat} package {[}13{]}, provides a simple interface for testing.
While a variety of test functions can make different comparisons, the two main ones are \texttt{expect\_true()} and \texttt{expect\_equal()}.
\texttt{expect\_true()} takes one argument: an expression that should evaluate to \texttt{TRUE}.
For our square root example above, we would write \texttt{expect\_true(sqrt(4)\ ==\ 2)}.
\texttt{expect\_equal()} takes two arguments, an expression and the expected output;
so we would write \texttt{expect\_equal(sqrt(4),\ 2)}.

There are a number of ways to incorporate unit testing into your programming workflow.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  As you write code, you should write tests that confirm it does what you expect.
\item
  These same tests should be regularly run as you develop new code.
  If a change causes the older tests to break, this points to the introduction of an error in the new code, or implies that the older code could not generalise to the adapted environment.
\item
  Whenever a bug is found in the code, a test should be written that captures it.
  Then if the bug re-emerges it will be caught.
\item
  You can write tests before you write code---also known as test-driven development.
  This can help development planning: write tests that define the desired functionality and continue programming, provided all tests keep passing.
  Frameworks for formalising this are discussed in Sections \ref{frameworks} and \href{ci}{7}.
\end{enumerate}

\hypertarget{bug-in-a-multi-strain-re-infection-model}{%
\section{Bug in a multi-strain re-infection model}\label{bug-in-a-multi-strain-re-infection-model}}

Here we define a simple epidemiological model and then demonstrate how to effectively write unit tests for it in \emph{R} code.

Consider a multi-strain system, with a population of \(N\) infected individuals who each get reinfected at every time step.
Each individual is defined by the strain they are currently infected with \(I_{it} \in \{a, b, c\}\) for a 3-strain system. So the the population is defined by a length \(N\) state vector \(\mathbf{I}_t\) = \((I_{it})_{i=[1,N]}\).
Each time step, everyone's infection status is updated as:
\[I_{it} = \text{Unif}(\mathbf{I}_{t-1}).\]
That is, at each iteration \(t\), the new infection status of each individual \(i\) is a Uniform random sample from the set of infection statuses in the previous iteration (including itself \(I_{i,t-1}\)).
Certainly this toy model is naÃ¯ve as it is governed by mass-action principles, ignoring contact and spatial dynamics.
Nevertheless it will serve its purpose.
Here is our first attempt at implementing this model.
\newline
\captionof{chunk}{Base example of the multi-strain re-infection model}\label{first_code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N <-}\StringTok{ }\DecValTok{12} \CommentTok{# infected individuals}
\NormalTok{t <-}\StringTok{ }\DecValTok{20} \CommentTok{# study length}
\CommentTok{# create the matrix to store the simulation data}
\NormalTok{I <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =}\NormalTok{ t, }\DataTypeTok{ncol =}\NormalTok{ N)}

\CommentTok{# Initialise the population at t = 1 with a fixed configuration}
\NormalTok{I[}\DecValTok{1}\NormalTok{,] <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DataTypeTok{length.out =}\NormalTok{ N)}

\CommentTok{# At each time step, everyone is re-infected }
\CommentTok{#   by someone from the previous time step.}
\ControlFlowTok{for}\NormalTok{(t }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, t))\{}
\NormalTok{  I[t,] <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ I[t}\DecValTok{-1}\NormalTok{,], }\DataTypeTok{size =}\NormalTok{ N)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Usually we would make some output plots to explore if our code is performing sensibly.
Plotting the time course of individuals' infection strain indicates repeated infection with different strains as expected (Fig. \ref{fig:firstplots}).
However, if we look at the proportion of each strain through time (not shown here) we quickly see that the strain proportions are identical through time and so there must be a bug hiding.

This simple example demonstrates that:

\begin{itemize}
\tightlist
\item
  bugs can be subtle
\item
  it is not easy to notice an error, even in just 7 lines of active code. Perhaps you can find it? The solution is in the next paragraph.
\item
  it is much easier to debug code when you now there is a bug.
\item
  while plotting simulation runs are an excellent way to check model behaviour, if we had only relied on Fig. \ref{fig:firstplots} we would have missed the bug. It is a generally ineffective method because a human has to perform this scan every test run.
\end{itemize}

In summary this \emph{ad hoc} plotting approach reduces the chances that we will catch all bugs.

\begin{figure}[h]

{\centering \includegraphics[width=0.6\textwidth,]{unit_testing_files/figure-latex/firstplots-1} 

}

\caption{Infection profile for individual 1.}\label{fig:firstplots}
\end{figure}

\emph{Solution}: \texttt{sample()} defaults to sampling without replacement \texttt{sample(...,\ replace\ =\ FALSE)}; this means everyone swaps their infection strain on a one-to-one basis rather than one-to-many as required by the model.
Setting \texttt{replace\ =\ TRUE} fixes this and when we plot the proportion of each strain (Fig. \ref{fig:correctplots}) we see the correct behaviour (one strain drifting to fixation).
We will now develop this example as we consider different concepts in unit testing, resulting in well-tested code by the end.
\newline

\begin{figure}[h]

{\centering \includegraphics[width=0.6\textwidth,]{unit_testing_files/figure-latex/correctplots-1} 

}

\caption{The correct behaviour with the proportion of each strain drifting. Each strain is a different line.}\label{fig:correctplots}
\end{figure}

\hypertarget{basic-testing}{%
\section{Basic testing}\label{basic-testing}}

To ensure the unit test is evaluating the same code as the actual analysis, it needs to be defined once within a single function.
This same function is then used for the unit test in isolation or as part of the larger model codebase.

\hypertarget{compactfuns}{%
\subsection*{Write compact functions}\label{compactfuns}}
\addcontentsline{toc}{subsection}{Write compact functions}

Make your functions compact with a single clearly-defined operation.
We have defined a function \texttt{initialisePop()} to initialise the population and another \texttt{updatePop()} to run the simulation.
Organising the codebase into these bite-sized operations makes following the programming flow easier as well as understanding the structure of the code.
We also modify \texttt{initialisePop(...,\ strains)} so that we can vary the number of strains.
\newline
\captionof{chunk}{Organising code into more compact functions}\label{compactfunctions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{initialisePop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(t, N, strains)\{}
\NormalTok{  I <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =}\NormalTok{ t, }\DataTypeTok{ncol =}\NormalTok{ N)}
\NormalTok{  I[}\DecValTok{1}\NormalTok{,] <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\NormalTok{strains], }\DataTypeTok{length.out =}\NormalTok{ N)}
  \KeywordTok{return}\NormalTok{(I)}
\NormalTok{\}}

\NormalTok{updatePop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, t, N)\{}
\NormalTok{  x[t,] <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x[t}\DecValTok{-1}\NormalTok{,], }\DataTypeTok{size =}\NormalTok{ N, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{easycases}{%
\subsection*{Test simple cases first}\label{easycases}}
\addcontentsline{toc}{subsection}{Test simple cases first}

If we start with a small population with few strains, we can then easily anticipate what we expect the initialised population to look like.
\newline
\captionof{chunk}{Using simple parameter sets we can work out beforehand what results to expect}\label{test_simple_first}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop1 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{2}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(pop1[}\DecValTok{1}\NormalTok{,], }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}

\NormalTok{pop2 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(pop2[}\DecValTok{1}\NormalTok{,], }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}

\NormalTok{pop3 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{4}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{2}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(pop3[}\DecValTok{1}\NormalTok{,], }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{testargs}{%
\subsection*{Test all arguments}\label{testargs}}
\addcontentsline{toc}{subsection}{Test all arguments}

\texttt{initialisePop()} has three arguments that require testing.
First we initialise the population, and then alter each argument in turn.
Arguments \texttt{t} and \texttt{N} directly change the expected dimension of matrix \texttt{I} so we check them together.
For the last argument we test that the number of strains is equal to the \texttt{strains} requested.
\newline
\captionof{chunk}{Test all function arguments in turn}\label{test_all_args}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop1 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(}\KeywordTok{dim}\NormalTok{(pop1), }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\NormalTok{pop2 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{6}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(}\KeywordTok{dim}\NormalTok{(pop2), }\KeywordTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\NormalTok{pop3 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{20}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(}\KeywordTok{dim}\NormalTok{(pop3), }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{20}\NormalTok{))}

\NormalTok{pop4 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{10}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{5}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(}\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(pop4[}\DecValTok{1}\NormalTok{,])), }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{complexcases}{%
\subsection*{Carefully work through more complex cases}\label{complexcases}}
\addcontentsline{toc}{subsection}{Carefully work through more complex cases}

We can also cover cases with more complex parameter values.
After initialising our population, we expect all the rows other than the first to contain \texttt{NA}.
We also expect each of the strains \(a\), \(b\) and \(c\) to occur at least once on the first row if \texttt{strains} \(\geq 3\) and \texttt{N} \(\geq 3\).
Finally, \texttt{updatePop()} performs one simulation time step, so we expect one additional row to be populated.
Instead of testing the exact values of the results, we check they make sense within our macro understanding of the model system.
\newline
\captionof{chunk}{Test more complex cases using your understanding of the system}\label{test_complex}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop1 <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{20}\NormalTok{, }\DataTypeTok{N =} \DecValTok{12}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{) }
\CommentTok{# expect all except the first row are NAs}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(pop1[}\OperatorTok{-}\DecValTok{1}\NormalTok{,]))) }
\CommentTok{# expect all 3 strains at t = 1}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{) }\OperatorTok{%in%}\StringTok{ }\NormalTok{pop1[}\DecValTok{1}\NormalTok{,])) }

\NormalTok{pop2 <-}\StringTok{ }\KeywordTok{updatePop}\NormalTok{(pop1, }\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{12}\NormalTok{)}
\CommentTok{# after update expect 1st & 2nd row not to have NAs}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(pop2[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{,]))) }
\end{Highlighting}
\end{Shaded}

\hypertarget{combine}{%
\subsection*{Combine simple functions and test them at a higher-level}\label{combine}}
\addcontentsline{toc}{subsection}{Combine simple functions and test them at a higher-level}

In the end an entire model only runs when its functions work together seamlessly.
So we next check their connections; achieved through nesting functions together, or defining them at a higher level.
Developing at a higher level means we should check macro aspects of the model.
We now expect there to be no \texttt{NA}s left in matrix \texttt{I} and every element to be one of the three strain strings.
\newline
\captionof{chunk}{Combine simple functions through nesting to check higher-level functionality}\label{combine_simple_func}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fullSim <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(t, N, strains)\{}
\NormalTok{  pop <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(t, N, strains) }
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, t))\{}
\NormalTok{    pop <-}\StringTok{ }\KeywordTok{updatePop}\NormalTok{(pop, i, N)}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(pop)}
\NormalTok{\}}

\NormalTok{pop <-}\StringTok{ }\KeywordTok{fullSim}\NormalTok{(}\DataTypeTok{t =} \DecValTok{12}\NormalTok{, }\DataTypeTok{N =} \DecValTok{20}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{)}
\KeywordTok{expect_true}\NormalTok{(}\OperatorTok{!}\KeywordTok{any}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(pop))) }\CommentTok{# expect no NAs}
\CommentTok{# expect all 3 strains contained within}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(pop }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))) }
\end{Highlighting}
\end{Shaded}

\hypertarget{stochastic-code}{%
\section{Stochastic code}\label{stochastic-code}}

Stochastic simulations are a common feature in infectious disease models.
Stochastic events are difficult to test effectively because, by definition, we do not know beforehand what the result will be.
We can check very broad-scale properties, like the test above, where we check the range of strain values.
However, code could still pass and be wrong (for example the original example would still pass that test).
There are however a number of approaches that can help.

\hypertarget{splitstochastic}{%
\subsection*{Split stochastic and deterministic parts}\label{splitstochastic}}
\addcontentsline{toc}{subsection}{Split stochastic and deterministic parts}

Isolate the stochastic parts of your code.
For example, \texttt{updatePop()} performs stochastic and deterministic operations in one line.
Firstly, \texttt{updatePop()} stochastically samples who gets infected by whom at iteration \texttt{t}.
Then it takes those infection events and assigns the new infectious status for each individual.
Finally, it adds the new infectious statuses to the full population matrix for that iteration.
So we could split these tasks up as follows.
\newline
\captionof{chunk}{Isolation of the determistic and stochastic elements}\label{split_deter_stoch}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chooseInfector <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(N)\{}
  \KeywordTok{sample}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ N, }\DataTypeTok{size =}\NormalTok{ N, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\NormalTok{newInfectionStatus <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(old_status, infector_strain)\{}
\NormalTok{  old_status[infector_strain]}
\NormalTok{\}}

\NormalTok{addInfectionStatus <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, t, new_status)\{}
\NormalTok{  x[t,] <-}\StringTok{ }\NormalTok{new_status}
\NormalTok{\}}

\NormalTok{updatePopCombined <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, t, N)\{}
\NormalTok{  infector_strain <-}\StringTok{ }\KeywordTok{chooseInfector}\NormalTok{(N)}
\NormalTok{  new_status <-}\StringTok{ }\KeywordTok{newInfectionStatus}\NormalTok{(x[t}\DecValTok{-1}\NormalTok{,], infector_strain)}
\NormalTok{  x[t,] <-}\StringTok{ }\KeywordTok{addInfectionStatus}\NormalTok{(x, t, new_status)}
  \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Two-thirds of \texttt{updatePopCombined()} is deterministic so can be checked using the ideas discussed previously.
However, we still have \texttt{chooseInfector()}, that is irreducibly stochastic.

\hypertarget{deterministicparams}{%
\subsection*{Pick a smart parameter for a deterministic result}\label{deterministicparams}}
\addcontentsline{toc}{subsection}{Pick a smart parameter for a deterministic result}

In the same way that we used simple parameters previously, we can often find parameter values for which our stochastic functions become deterministic.
For example, samples from \(X\sim\text{Bernoulli}(p)\) always give zeroes for \(p=0\) or ones for \(p=1\).
In the case here where we only have one strain, the model is no longer stochastic.
So initialisation with one strain means the second time step should equal the first.
\newline
\captionof{chunk}{A stochastic function can output deterministically if you can find the right parameter set.}\label{test_stoch_determin}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{1}\NormalTok{) }
\NormalTok{pop <-}\StringTok{ }\KeywordTok{updatePop}\NormalTok{(pop, }\DataTypeTok{t =} \DecValTok{2}\NormalTok{, }\DataTypeTok{N =} \DecValTok{3}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(pop[}\DecValTok{1}\NormalTok{,], pop[}\DecValTok{2}\NormalTok{,])}
\end{Highlighting}
\end{Shaded}

\hypertarget{allpossible}{%
\subsection*{Test all possible answers (if few)}\label{allpossible}}
\addcontentsline{toc}{subsection}{Test all possible answers (if few)}

Working again with a simple parameter set, there are some cases where the code is stochastic, but with a small, finite set of outputs.
So we can run the function exhaustively and check it returns all of the possible outputs.
For a population of two people, there are four possibilities when drawing who is infected by whom.
Individual 1 can be infected by themselves (\{1,\}) or individual 2 (\{2,\}), and individual 2 infected by themselves (\{,2\}) or individual 1 (\{,1\}).
\newline
\captionof{chunk}{Testing stochastic output when it only covers a few finite values}\label{test_stoch_fewvalues}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Collapse each draw into a single string to make comparisons easier.}
\NormalTok{manyPops <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{300}\NormalTok{, }\KeywordTok{paste0}\NormalTok{(}\KeywordTok{chooseInfector}\NormalTok{(}\DataTypeTok{N =} \DecValTok{2}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{))}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(manyPops }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"11"}\NormalTok{, }\StringTok{"12"}\NormalTok{, }\StringTok{"21"}\NormalTok{, }\StringTok{"22"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{largesamples}{%
\subsection*{Use very large samples for the stochastic part}\label{largesamples}}
\addcontentsline{toc}{subsection}{Use very large samples for the stochastic part}

While the previous example worked well for a small set of possible outputs, testing can conversely be made easier by using very large numbers.
This typically involves large sample sizes or numbers of stochastic runs.
For example, the clearest test to distinguish between our original, buggy code and our correct code is that in the correct code there is the possibility for one individual to infect more than one in a single time step.
In any given run this is never guaranteed, but the larger the population size (and equivalently the sample size) the more likely it is to occur.
Though we need to be sure that the failure of the test is very rare.
We set the seed of a random number generator so that the test is reproducible, otherwise the test will fail sporadically and unpredicatably.

We can calculate the probability of this test failing for a population with \(n\) individuals---it is the well-known `birthday paradox'.
There are `\(n\) choose 2' \(\binom{n}{2}\) possible pairs of individuals.
The probability of a pair \(<i,j>\) not being infected by the other is \(1-\frac{1}{n}\) (given that the first person is infected by someone \(i\), the probability that the second person \(j\) is infected by the same \(i\) is just \(1/n\)).
For the test to fail, every pair would have to not be infected by the other, giving \(\big(1-\frac{1}{n}\big) ^ {\binom{n}{2}}\).
For a population with 100 individuals, the probability of the test failing (if programmed correctly) is \(10^{-21}\) and vanishingly small for 1000 individuals.
\newline
\captionof{chunk}{Computing the probability of the stochastic test failing for 1000 individuals}\label{test_stoch_largenum}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{10261985}\NormalTok{)}
\NormalTok{n <-}\StringTok{ }\FloatTok{1e3}
\NormalTok{infector_strain <-}\StringTok{ }\KeywordTok{chooseInfector}\NormalTok{(n)}
\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{any}\NormalTok{(}\KeywordTok{duplicated}\NormalTok{(infector_strain)))}

\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{n)) }\OperatorTok{^}\StringTok{ }\KeywordTok{choose}\NormalTok{(n, }\DecValTok{2}\NormalTok{) }\CommentTok{# probability of failing}
\end{Highlighting}
\end{Shaded}

If we have an event that we know should not happen, we can use a large number of simulations to provide stronger evidence that is does not stochastically occur.
However, it can be difficult to determine how many times is reasonable to run a simulation, especially if time is short.
This strategy works best when we have a specific bug that occurred relatively frequently (perhaps once every ten simulations or so).
We say that if the bug does not occur even once in 500 simulations, then we are pretty sure we have fixed it.
In our original buggy code we found that the proportions remained identical for entire simulations.
For a reasonably large simulation we would expect this to happen seldom, so we can run the full simulation a number of times to check that this specific bug does not occur.
\newline
\captionof{chunk}{Assessing if a bug fix was a likely success with large code runs, when the bug was appearing relatively frequently}\label{returningstrain}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{11121955}\NormalTok{)}
\NormalTok{manySims <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{500}\NormalTok{, }\KeywordTok{fullSim}\NormalTok{(}\DataTypeTok{t =} \DecValTok{30}\NormalTok{, }\DataTypeTok{N =} \DecValTok{40}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{), }
                      \DataTypeTok{simplify =} \OtherTok{FALSE}\NormalTok{)}

\KeywordTok{expect_true}\NormalTok{(}\KeywordTok{all}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(manySims, }
                       \ControlFlowTok{function}\NormalTok{(x) }
                         \KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(}\KeywordTok{apply}\NormalTok{(x, }\DecValTok{1}\NormalTok{, table))) }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{further-testing}{%
\section{Further testing}\label{further-testing}}

\hypertarget{corners}{%
\subsection*{Test edge cases and special cases}\label{corners}}
\addcontentsline{toc}{subsection}{Test edge cases and special cases}

When writing tests it is easy to focus on standard behaviour.
However, bugs often occur at \emph{edge cases}---when parameters are at their extrema or at special values.

For example, in \emph{R}, selecting one column from a matrix e.g. \texttt{{[},2{]}} returns a vector while selecting two or more columns e.g. \texttt{{[},2:3{]}} returns a matrix.
Code that relies on the returned object being a matrix would fail this vector edge case.

Equally special cases can be triggered with parameter sets that do not match the extrema of parameter space.
This is where understanding of the functional form of the model can help. Consider a function \texttt{divide(x,\ y)} that divides \texttt{x} by \texttt{y}.
If we test the (mathematically bloated) calculation \texttt{2\ *\ divide(x,\ 2)\ ==\ x} we would believe it works for nearly all values of division, unless we ever try \texttt{y\ =\ 0}.

In our example model, we might consider testing edge cases such as one individual, one iteration and one strain.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop <-}\StringTok{ }\KeywordTok{fullSim}\NormalTok{(}\DataTypeTok{t =} \DecValTok{1}\NormalTok{, }\DataTypeTok{N =} \DecValTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In fact, running \texttt{fullSim()} with only one iteration, errors without a useful error message.
We have fixed this with an error check at the top of the function that returns a more useful error message if \texttt{t\ =\ 1} (or any integer less than two) is used.
\newline
\captionof{chunk}{Testing a special case}\label{erroronspecialcase}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fullSim2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(t, N, strains)\{}
  \KeywordTok{stopifnot}\NormalTok{(t }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{  pop <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(t, N, strains) }
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, t))\{}
\NormalTok{    pop <-}\StringTok{ }\KeywordTok{updatePop}\NormalTok{(pop, i, N)}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(pop)}
\NormalTok{\}}
\NormalTok{pop <-}\StringTok{ }\KeywordTok{fullSim2}\NormalTok{(}\DataTypeTok{t =} \DecValTok{1}\NormalTok{, }\DataTypeTok{N =} \DecValTok{12}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Similarly, we checked earlier if the \texttt{strains} argument of \texttt{initialisePop()} worked by verifying if the returned population had the correct number of strains.
However, if we set the \texttt{strains} argument to be greater than the number of individuals in the population, the current function does not error nor give the answer we expected either.
\newline
\captionof{chunk}{Sometimes the best way to avoid bugs it using adequate error checks on variables at the function start}\label{edge2}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(}\DataTypeTok{t =} \DecValTok{10}\NormalTok{, }\DataTypeTok{N =} \DecValTok{2}\NormalTok{, }\DataTypeTok{strains =} \DecValTok{11}\NormalTok{) }
\KeywordTok{expect_equal}\NormalTok{(}\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(pop[}\DecValTok{1}\NormalTok{,])), }\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here again the best solution is a \texttt{stopifnot(strains\ \textgreater{}\ N)} error check at the beginning of the function.

\hypertarget{testincorrect}{%
\subsection*{Test incorrect inputs}\label{testincorrect}}
\addcontentsline{toc}{subsection}{Test incorrect inputs}

Bugs may be discovered by other users when new uncleaned data meets functions previously tested on complete datasets.
Therefore it is useful to test that functions fail gracefully if they are given inputs of the wrong class.
This is especially true for `external' functions, available to a user on a package's front-end.
Some cases may quickly fail, but sometimes code may run silently giving false results or take long to reach failure.
Both of these cases are serious or annoying and can be difficult to debug afterwards.

A common case to check with epidemiological datasets is whether code correctly handles missing data (normally represented as \texttt{NA}, \texttt{"\ "} or \texttt{\textquotesingle{}\textquotesingle{}}).
Often the simplest solution is to include argument checks at the beginning of functions and use \texttt{expect\_error()} to error check.

We check how the code handles a user inputting a vector of numbers to the \texttt{t} argument (perhaps thinking it needed a vector of all time points to run).
We have also updated \texttt{fullSim3()} to provide a check on the length of \texttt{t} with an informative message.
\newline
\captionof{chunk}{Testing incorrect inputs}\label{wrong1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expect_error}\NormalTok{(pop <-}\StringTok{ }\KeywordTok{fullSim}\NormalTok{(}\DataTypeTok{t =} \DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DataTypeTok{N =} \DecValTok{4}\NormalTok{))}

\NormalTok{fullSim3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(t, N, strains)\{}
  \KeywordTok{stopifnot}\NormalTok{(t }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(t) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{  pop <-}\StringTok{ }\KeywordTok{initialisePop}\NormalTok{(t, N, strains) }
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, t))\{}
\NormalTok{    pop <-}\StringTok{ }\KeywordTok{updatePop}\NormalTok{(pop, i, N)}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(pop)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{frameworks}{%
\section{Unit testing frameworks}\label{frameworks}}

Most programming languages have established testing packages.
For \emph{R}, there is the \(\texttt{testthat}\) package.
When structuring \emph{R} code as a package, tests should be kept in the directory \texttt{tests/testthat}; further requirements to the structure can be found in {[}7{]} Chapter 7.
All the tests in a package can then be run with \texttt{test()} from the \(\texttt{devtools}\) package {[}14{]} or \texttt{check()} for additional checks relevant to a package build.
If the code is to be part of a package then these tools are essential to run the code within the context of a build environment.
These tools also provide a clean environment to highlight if a test was previously relying on objects defined outside of the test script.

Other programming languages have similar testing frameworks too.
Their specifics differ but the main concept of comparing a function evaluation to the expected output remains the same.
In \emph{Julia} there is the \(\texttt{Test}\) package {[}15{]}.
The basic structure for tests with this package are demonstrated below.
We give the specific test a name and give a single expression that evaluates to \texttt{TRUE} or \texttt{FALSE}.
For a \emph{Julia} package unit tests reside in \texttt{test/runtests.jl} and tests are run with \texttt{Pkg.test()}.
\newline
\captionof{chunk}{Julia test example}\label{juliatest}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{@}\NormalTok{testset }\StringTok{"my_test_name"}\NormalTok{ begin}
  \OperatorTok{@}\NormalTok{test }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{4}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{2}
\NormalTok{end}
\end{Highlighting}
\end{Shaded}

Finally, in \emph{python} we have the \(\texttt{unittest}\) framework {[}16{]}; tests must be written into a class that inherits from the \texttt{TestCase} class.
The tests must be written as methods with \texttt{self} as the first argument.
An example test script is shown below.
Tests should be kept in a directory called \texttt{Lib/test}, and the filename of every file with tests should begin with \texttt{test\_}.
\newline
\captionof{chunk}{python test example}\label{testpy}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{import unittest}
\NormalTok{import math}

\NormalTok{class }\KeywordTok{TestMaths}\NormalTok{(unittest.TestCase)}\OperatorTok{:}
\StringTok{    }\NormalTok{def }\KeywordTok{test_sqrt}\NormalTok{(self)}\OperatorTok{:}
\StringTok{        }\KeywordTok{self.assertEqual}\NormalTok{(}\KeywordTok{math.sqrt}\NormalTok{(}\DecValTok{4}\NormalTok{), }\DecValTok{2}\NormalTok{)}

\KeywordTok{unittest.main}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{ci}{%
\section{Continuous integration}\label{ci}}

If your code is under version control {[}8,9{]} and hosted on GitHub, GitLab or BitBucket, you can automate the running of unit tests---also known as \emph{continuous integration}.
In this setup, whenever you push code changes from your local computer to the online repository, any tests that you have defined get run automatically.
Furthermore these tests can be automated irrespective of changes to your code or tests: since dependencies with other packages and knock-on changes from them into a bug in your code can be automatically found and notified to you by email.
There are various continuous integration services such as travis-ci.org, GitHub actions and GitLab pipelines.
These services are often free on a limited basis, or free if your code is open source.

We briefly describe the setup of the simplest case.
For \emph{R} code organised into a package and hosted openly on GitHub, then setting up travis CI is very straightforward.
Within your version-controlled folder you add a one-liner \texttt{.travis.yml} file that contains a description of which language the code uses.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{language}\OperatorTok{:}\NormalTok{r}
\end{Highlighting}
\end{Shaded}

This file can also be created using \texttt{use\_travis()} from the \(\texttt{usethis}\) package.
You then need to sign up to travis-ci.org and point it to the correct GitHub repository.
To authenticate and trigger the first automatic test you need to make a minor change to your code, commit and push to GitHub.
More details can be found in {[}7{]} Chapter 14.3.

\hypertarget{conclusions}{%
\section{Conclusions}\label{conclusions}}

It is vital that infectious disease models are coded to minimise bugs.
Unit testing is the principled way we can do this.
There are many frameworks that make aspects of testing automatic and more informative and these should be used where possible.
Setting it up is simple but writing good tests is a skill that takes time, practice and thought, but also saves time, effort and unintended harm from incorrect code.

\hypertarget{code-availability}{%
\section{Code availability}\label{code-availability}}

Please see the fully-reproducible and version-controlled code at \url{www.github.com/timcdlucas/unit_test_for_infectious_disease}.

\hypertarget{references}{%
\section*{References}\label{references}}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-ihme}{}%
1. IHME COVID-19 health service utilization forecasting team, Murray CJ. Forecasting COVID-19 impact on hospital bed-days, ICU-days, ventilator days and deaths by US state in the next 4 months. medRxiv. 2020; doi:\href{https://doi.org/10.1101/2020.03.27.20043752}{10.1101/2020.03.27.20043752}

\leavevmode\hypertarget{ref-imperial}{}%
2. Ferguson NM, Laydon D, Nedjati-Gilani G, Imai N, Ainslie K, Baguelin M, et al. Impact of non-pharmaceutical interventions (NPIs) to reduce COVID-19 mortality and healthcare demand. 2020; Available: \url{https://www.imperial.ac.uk/mrc-global-infectious-disease-analysis/covid-19/report-9-impact-of-npis-on-covid-19/}

\leavevmode\hypertarget{ref-hellewell2020feasibility}{}%
3. Hellewell J, Abbott S, Gimma A, Bosse NI, Jarvis CI, Russell TW, et al. Feasibility of controlling COVID-19 outbreaks by isolation of cases and contacts. Lancet. Elsevier; 2020;

\leavevmode\hypertarget{ref-ferg_tweet}{}%
4. Ferguson NM. Tweet from @neil\_ferguson. \url{https://twitter.com/neil_ferguson/status/1241835454707699713}; 2020.

\leavevmode\hypertarget{ref-willem2017lessons}{}%
5. Willem L, Verelst F, Bilcke J, Hens N, Beutels P. Lessons from a decade of individual-based models for infectious disease transmission: a systematic review (2006-2015). BMC Infect Dis. Springer; 2017;17: 612.

\leavevmode\hypertarget{ref-ferguson2006strategies}{}%
6. Ferguson NM, Cummings DA, Fraser C, Cajka JC, Cooley PC, Burke DS. Strategies for mitigating an influenza pandemic. Nature. Nature Publishing Group; 2006;442: 448--452.

\leavevmode\hypertarget{ref-wickham2015r}{}%
7. Wickham H. R packages: Organize, test, document, and share your code. O'Reilly Media, Inc. 2015.

\leavevmode\hypertarget{ref-osborne2014ten}{}%
8. Osborne JM, Bernabeu MO, Bruna M, Calderhead B, Cooper J, Dalchau N, et al. Ten simple rules for effective computational research. PLOS Comput Biol. Public Library of Science; 2014;10.

\leavevmode\hypertarget{ref-wilson2014best}{}%
9. Wilson G, Aruliah DA, Brown CT, Chue Hong NP, Davis M, Guy RT, et al. Best practices for scientific computing. PLOS Biol. Public Library of Science; 2014;12.

\leavevmode\hypertarget{ref-R}{}%
10. R Core Team. \emph{R} v3.6.3: A language and environment for statistical computing {[}Internet{]}. Vienna, Austria: R Foundation for Statistical Computing; 2018. Available: \url{https://www.R-project.org/}

\leavevmode\hypertarget{ref-bezanson2017julia}{}%
11. Bezanson J, Edelman A, Karpinski S, Shah VB. \emph{Julia}: A fresh approach to numerical computing. SIAM rev. SIAM; 2017;59: 65--98. Available: \url{https://doi.org/10.1137/141000671}

\leavevmode\hypertarget{ref-python}{}%
12. Python Core Team. \emph{Python} v3.8.2: A dynamic, open source programming language {[}Internet{]}. Python Software Foundation; 2015. Available: \url{https://www.python.org/}

\leavevmode\hypertarget{ref-testthat}{}%
13. Wickham H. \texttt{testthat} V.2.3.2: Get started with testing. R J. 2011;3: 5--10. Available: \url{https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf}

\leavevmode\hypertarget{ref-devtools}{}%
14. Wickham H, Hester J, Chang W, RStudio, R Core Team. \texttt{devtools} V2.3.0: Tools to make developing r packages easier {[}Internet{]}. 2019. Available: \url{https://CRAN.R-project.org/package=devtools}

\leavevmode\hypertarget{ref-juliatest}{}%
15. Bezanson J, Edelman A, Karpinski S, Shah VB, contributers. \texttt{test} V1.4.1: Simple unit testing functionality in julia {[}Internet{]}. 2017. Available: \url{https://github.com/JuliaLang/julia/blob/master/stdlib/Test/src/Test.jl}

\leavevmode\hypertarget{ref-pythonunittest}{}%
16. Python Core Team. \texttt{unittest} V3.8.2: Unit testing framework {[}Internet{]}. 2015. Available: \url{https://docs.python.org/3/library/unittest.html}

\nolinenumbers


\end{document}

